## 在浏览器输入一个URL后回车发生了什么
- URL 解析
    + 首先浏览器会对用户输入url进行解析 确定Web服务器和文件名
    + 然后判断是http 还是 https 访问服务器，如果没有明确告知浏览器是用哪个协议，浏览器会默认使用http协议
- DNS 查询 获取对应的 IP 地址
<img src='../images/DNS.jpg'>
    + 1、浏览器缓存
        + 浏览器会先检查是否在缓存中，没有则调用系统函数进行查询。
    + 2、操作系统缓存
        + 操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有泽祥 DNS 服务器发送查询请求。
    + 3、路由缓存
    + 4、 ISP DNS 缓存
    + 5、根域名服务器查询
    <img src="../images/DNS查询.jpg">
+ TCP 连接
    + TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装
    <img src="../images/TCP 连接.jpg">
        + 1、应用层：发送 HTTP 请求
        + 2、传输层：TCP传输报文
            + TCP 三次握手
                + 客户端会给服务端发送一个带 SYN 标志的数据包
                + 服务端收到后会回传一个带有 SYN/ACK 的数据包以表示正确传达
                + 客户端在回传一个带 ACK 标志的数据包，以代表”握手“结束
                + 若在握手过程中的某个阶段莫名中断，TCP 会再次以相同的顺序发送相同的数据包
            + TCP 四次挥手
                + 主动关闭方会发送一个 FIN，用来关闭数据传输（如果被动方没用收到确认报文，关闭方依然会重新发送这些数据）
                + 被动方收到 FIN 包后，会给对方发送一个 ACK，确认收到
                + 被动方会发送一个 FIN 用来关闭被动到主动的数据传输
                + 主动方接受到 FIN 后，会给被动方发送一个 ACK 确认
        + 3、网络层：IP 协议查询 Mac 地址
            + 将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线
        + 4、链路层：以太网协议
            + 根据以太网协议将数据分为以"帧"为单位的数据包，每一帧分为两部分：
                + 标头：数据包的发送者、接受着、数据类型
                + 数据：数据包具体内容
+ 处理请求
+ 接收响应
    + 接受服务器的响应资源后，会对资源进行分析
+ 渲染页面 

---

## 前端 SEO 优化
+ 合理的标题、描述、关键词
    + 标题值可以强调重点、重点关键次不要出现超过2次，而且要靠前，不同页面标题不同
    + 描述高度概括页面内容，长度合适，不要堆砌关键词，不同页面描述不同
    + 关键词可以列举重要关键词即可
+ 语义化 HTML 代码：语义化代码让搜索引擎容易理解网易
+ 重要的内不要让js输出：爬虫不会执行 js 获取内容
+ 少用 iframe：搜索引擎不会抓取到的内容
+ 被装饰性图片必须加 alt
+ 提交网站速度：网站速度是搜索引擎排序的一个重要指标

---

## JSONP
+ 同源策略
    + 同源是指域名、协议、端口相同
    + 同源策略就是基于安全考虑，当前域不能访问其他域的东西
+ jsonp 基本原理主要是利用 script 标签的 src 没有跨域限制来完成的

---

## Node 事件循环与浏览器事件循环区别
+ microtask(微任务)任务队列的执行时机不同
    + Node 端，microtask(微任务)在事件循环的各个阶段之间执行
    + 浏览器端，microtask(微任务)在事件循环的 macrotask(宏任务)执行完之后执行

---

## HTTP 缓存
+ ### 强缓存
    + 指浏览器直接从浏览器缓存中读取资源，不请求服务器，状态码显示200
    + 资源强缓存，主要跟 max-age 有关，也就是初次请求过来携带的过期时间，主要跟 expires 和 cache-control 有关
        + expires 是http 1.0的产物
        + cache-control 是http1.1的产物
+ ### 协商缓存
    + 指浏览器向服务器发送请求，并且跟据 request headers 中携带的数据判断是否需要从缓存中读取，如何判断资源未发生变动，则返回304，并且从通过新的 response headers 让浏览器从缓存中读取资源


## 大文件分片上传+断点续传
    + 分片上传
        + 根据定义的每个分片的大小将上传的文件进行切割并存储到数组中
            + star：当前已切割的片长度 * 每个分片的大小
            + end：star + 每个分片的大小，需要判断是否是最后一片   
    + 断点续传
        + 前端生成唯一 uuid 在上传之前进行请求判断，如果当前块已有上传过则继续上传