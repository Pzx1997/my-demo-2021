## 在浏览器输入一个 URL 后回车发生了什么

-   URL 解析
    -   首先浏览器会对用户输入 url 进行解析 确定 Web 服务器和文件名
    -   然后判断是 http 还是 https 访问服务器，如果没有明确告知浏览器是用哪个协议，浏览器会默认使用 http 协议
-   DNS 查询 获取对应的 IP 地址
    <img src='../images/DNS.jpg'> + 1、浏览器缓存 + 浏览器会先检查是否在缓存中，没有则调用系统函数进行查询。 + 2、操作系统缓存 + 操作系统也有自己的 DNS 缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有泽祥 DNS 服务器发送查询请求。 + 3、路由缓存 + 4、 ISP DNS 缓存 + 5、根域名服务器查询
    <img src="../images/DNS查询.jpg">

*   TCP 连接
    -   TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装
        <img src="../images/TCP 连接.jpg"> + 1、应用层：发送 HTTP 请求 + 2、传输层：TCP 传输报文 + TCP 三次握手 + 客户端会给服务端发送一个带 SYN 标志的数据包 + 服务端收到后会回传一个带有 SYN/ACK 的数据包以表示正确传达 + 客户端在回传一个带 ACK 标志的数据包，以代表”握手“结束 + 若在握手过程中的某个阶段莫名中断，TCP 会再次以相同的顺序发送相同的数据包 + TCP 四次挥手 + 主动关闭方会发送一个 FIN，用来关闭数据传输（如果被动方没用收到确认报文，关闭方依然会重新发送这些数据） + 被动方收到 FIN 包后，会给对方发送一个 ACK，确认收到 + 被动方会发送一个 FIN 用来关闭被动到主动的数据传输 + 主动方接受到 FIN 后，会给被动方发送一个 ACK 确认 + 3、网络层：IP 协议查询 Mac 地址 + 将数据段打包，并加入源及目标的 IP 地址，并且负责寻找传输路线 + 4、链路层：以太网协议 + 根据以太网协议将数据分为以"帧"为单位的数据包，每一帧分为两部分： + 标头：数据包的发送者、接受着、数据类型 + 数据：数据包具体内容
*   处理请求
*   接收响应
    -   接受服务器的响应资源后，会对资源进行分析
*   渲染页面

---

## 前端 SEO 优化

-   合理的标题、描述、关键词
    -   标题值可以强调重点、重点关键次不要出现超过 2 次，而且要靠前，不同页面标题不同
    -   描述高度概括页面内容，长度合适，不要堆砌关键词，不同页面描述不同
    -   关键词可以列举重要关键词即可
-   语义化 HTML 代码：语义化代码让搜索引擎容易理解网易
-   重要的内不要让 js 输出：爬虫不会执行 js 获取内容
-   少用 iframe：搜索引擎不会抓取到的内容
-   被装饰性图片必须加 alt
-   提交网站速度：网站速度是搜索引擎排序的一个重要指标

---

## JSONP

-   同源策略
    -   同源是指域名、协议、端口相同
    -   同源策略就是基于安全考虑，当前域不能访问其他域的东西
-   jsonp 基本原理主要是利用 script 标签的 src 没有跨域限制来完成的

---

## Node 事件循环与浏览器事件循环区别

-   microtask(微任务)任务队列的执行时机不同
    -   Node 端，microtask(微任务)在事件循环的各个阶段之间执行
    -   浏览器端，microtask(微任务)在事件循环的 macrotask(宏任务)执行完之后执行

---

## HTTP 缓存

-   ### 强缓存
    -   指浏览器直接从浏览器缓存中读取资源，不请求服务器，状态码显示 200
    -   资源强缓存，主要跟 max-age 有关，也就是初次请求过来携带的过期时间，主要跟 expires 和 cache-control 有关
        -   expires 是 http 1.0 的产物
        -   cache-control 是 http1.1 的产物
-   ### 协商缓存
    -   指浏览器向服务器发送请求，并且跟据 request headers 中携带的数据判断是否需要从缓存中读取，如何判断资源未发生变动，则返回 304，并且从通过新的 response headers 让浏览器从缓存中读取资源

## 大文件分片上传+断点续传

    + 分片上传
        + 根据定义的每个分片的大小将上传的文件进行切割并存储到数组中
            + star：当前已切割的片长度 * 每个分片的大小
            + end：star + 每个分片的大小，需要判断是否是最后一片
    + 断点续传
        + 前端生成唯一 uuid 在上传之前进行请求判断，如果当前块已有上传过则继续上传

---

## H5 新增特性

-   语义化标签
    -   header，footer，nav，section，aside，article
-   表单属性
    -   type：date，time，email，number，url
    -   placehoder
    -   min 和 max
-   video / radio
-   canvas

---

## CSS3 新增特性

-   过渡 transition
-   动画 animation
	-	定义 @keyframes
-   形状转换 transform
	-	translate 平移
	-	scale 缩放
	-	rotate 旋转
	-	skew 倾斜/翻转/扭曲(2D独有)
	-	transform-origin 改变参考点	
-   选择器
    -   :last-child
    -   :first-child
    -   :nth-child
    -   :disabled
    -   :checked
    -   :not(selector)
    -   ::selection
    -   伪类 :hover :focus
    -   伪元素:: after ::before
-   文本阴影 text-shadow
-   阴影 box-shadow
-   边框 boder-image
-   背景 background
-   渐变 linear-gradient
-   弹性布局 flex
-   盒模型
    -   border-box; 边框和 padding 包含在元素的宽高之内
    -   content-box 边框和 padding 不包含在元素的宽高之内
-   媒体查询 @media

---

## ES6新增特性

---

## cookie localstorage sessionstorage 有什么区别
-	cookies：大小只有4kb，不设定有效期过期后将会删除，不设定则关闭浏览器删除。还需要指定作用域，不可以跨域调用，需要自己封装setCookie，getCookie
-	localstorage：用于持久化的本地存储，除非主动删除，否则数据是永远不会过去
-	sessionstorage：用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问并且当前会话结束后数据也会被随之销毁

---

## call 和 apply 的区别

- 二者的作用完全一样，只是接受参数的方式不一样，参数1是this, call 需要把参数按顺序传递进去，而apply 则是把参数放在数组里，若第一个参数为null，那么函数中的 this 指向 window

---

## 继承的方法

- 原型链继承
  - 让新实例的原型等于父类的实例，实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性（新实例不会继承父类实例的属性）
  - 缺点：
    - 新实例无法向父类构造函数传参
    - 继承单一
    - 所有新实例都会共享父类实例的属性（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的属性也会被修改）
- 借用构造函数继承
  - 用 call 和 apply 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行）
  - 特点
    - 只继承了父类构造函数的属性，没有继承父类原型的属性
    - 可以继承多个构造函数的属性
    - 在子实例中可向父实例传参
  - 缺点
    - 只能继承父类构造函数的属性
    - 无法实现构造函数的复用（每次用都要重新调用）
    - 每个新实例都有父类构造函数的副本
- 组合继承
  - 结合了原型链继承和构造函数继承的优点，传参和复用
  - 特点
    - 可以继承父类原型上的属性，可以传参，可以复用
    - 每个新实例引入的构造函数属性是私有的
  - 缺点
    - 调用了两次父类构造函数，子类的构造函数会替代原型上的那个父类构造函数

- 原型式继承
  - 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象
  - 特点
    - 类似于复制一个对象，用函数来包装
  - 缺点
    - 无法实现复用（新实例属性都是后面添加的）
- 寄生式继承
  - 给原型式继承外面调了个壳子
  - 特点
    - 没有创建自定义类型，因为只是套了个壳子返回对象，这个函数顺理成章的就成了创建的新对象
  - 缺点
    - 没用到原型，无法复用
- 寄生组合式继承
  - 寄生：在函数内返回对象然后调用
  - 组合：函数的原型等于另一个实例。在函数中用 apply 或 call 引入另一个构造函数，可传参
  - 修复了组合继承的问题